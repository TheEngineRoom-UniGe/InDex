updating two MPU9250 at the same lane , make some delay problems. 
the readByte function is using endTransmission(false)
which reserves the bus for the first one who called it.
Putting it to false, it make a NACK when trying to check the interrupt status, i.e. reading the 3A address . 
w1.00wa0.00ab0.00bc0.00c
read byte 104 sub :58I2C ERROR CODE : 2  // 104 is the 0x68 
read byte 105 sub :58I2C ERROR CODE : 2  // 58 is the 0x3A , interrupt add.
read byte 105 sub :58I2C ERROR CODE : 2
w1.00wa0.00ab0.00bc0.00c
// adding delays between the two sensors, did not help , same error

Another thing to take care of , is to know that the magnetometer has the 0x0C address, then when putting them on the same bus , we should enable the master mode on one of the two IMUs. 

This is the normal behaviour: 
writeByte(MPU9250_ADDRESS, I2C_MST_CTRL, 0x00); // Disable I2C master // 0x0D for 400 khz clock
writeByte(MPU9250_ADDRESS, USER_CTRL, 0x00);    // Disable FIFO and I2C master modes //  0x20 for master mode

This was solved, and library is changed to put the mag data in the FIFO, here the MPU9250 has a master I2C, which reads from the Mag as slave, Mag is no visible on the main I2C lane


25/01/2021

// Removing all the send , and keeping the updates, raises the topic's HZ to 35 instead of 28 (8 sensors)
// removing updateMag() from the library, raises the HZ to 62 (8 sensors)
// removing the while(!(readByte(MPU9250_ADDRESS, EXT_SENS_DATA_00) & 0x01)); , raises the HZ to 52
The most expensive function is the mpu9250.update

Using the wire1 library, it is possible to use the second I2C interface. 
Wire1.begin (D7,D8,400000);  // Data , clock ,frequency , The current configuration works fine 





